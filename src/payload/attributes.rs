use alloy_primitives::Bytes as AlloyBytes;
use alloy_rpc_types_engine::PayloadAttributes as EthPayloadAttributes;
use alloy_rpc_types_eth::Withdrawal;
use reth_payload_primitives::PayloadAttributes;
use reth_revm::primitives::{Address, B256, U256};
use serde_with::{Bytes, base64::Base64, serde_as};

/// Taiko Payload Attributes
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
pub struct TaikoPayloadAttributes {
    /// The ETH payload attributes
    #[cfg_attr(feature = "serde", serde(flatten))]
    pub payload_attributes: EthPayloadAttributes,
    /// Base fee per gas for the L2 block.
    pub base_fee_per_gas: U256,
    /// The metadata for the L2 block.
    pub block_metadata: TaikoBlockMetadata,
    /// The L1 origin information for the L2 block.
    pub l1_origin: RpcL1Origin,
}

impl PayloadAttributes for TaikoPayloadAttributes {
    /// Returns the timestamp to be used in the payload job.
    fn timestamp(&self) -> u64 {
        self.payload_attributes.timestamp()
    }

    /// Returns the withdrawals for the given payload attributes.
    fn withdrawals(&self) -> Option<&Vec<Withdrawal>> {
        self.payload_attributes.withdrawals()
    }

    /// Return the parent beacon block root for the payload attributes.
    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.payload_attributes.parent_beacon_block_root()
    }
}

/// The metadata for a Taiko block, which is generated by the Taiko protocol.
#[serde_as]
#[derive(Clone, Debug, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
pub struct TaikoBlockMetadata {
    /// The suggested fee recipient address for the L2 block.
    pub beneficiary: Address,
    /// The gas limit for the L2 block.
    pub gas_limit: u64,
    /// The timestamp for the L2 block.
    pub timestamp: U256,
    /// The mix hash for the L2 block.
    pub mix_hash: B256,
    /// The RLP-encoded transaction list for the L2 block.
    pub tx_list: AlloyBytes,
    /// The extra data for the L2 block.
    #[serde_as(as = "Base64")]
    pub extra_data: AlloyBytes,
}

/// The L1 origin information for a Taiko block, which includes the information about the L1 block
/// that including the given L2 block.
#[serde_as]
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "camelCase"))]
pub struct RpcL1Origin {
    /// The number of the L2 block.
    #[serde(rename = "blockID")]
    pub block_id: U256,
    /// The hash of the L2 block.
    pub l2_block_hash: B256,
    /// The height of the L1 block that included the L2 block.
    pub l1_block_height: Option<U256>,
    /// The hash of the L1 block that included the L2 block.
    pub l1_block_hash: Option<B256>,
    /// The ID of the build payload arguments.
    #[serde(rename = "buildPayloadArgsID")]
    pub build_payload_args_id: [u8; 8],
    /// Indicates if the L2 block was included as a forced inclusion.
    pub is_forced_inclusion: bool,
    /// The signature of the L2 block payload.
    #[serde_as(as = "Bytes")]
    pub signature: [u8; 65],
}

impl RpcL1Origin {
    /// Checks if the L1 origin's L2 block is a preconfirmation block.
    pub fn is_preconf_block(&self) -> bool {
        self.l1_block_height.is_none() || self.l1_block_height == Some(U256::ZERO)
    }
}

#[cfg(feature = "db")]
impl From<crate::db::model::StoredL1Origin> for RpcL1Origin {
    // Converts a `StoredL1Origin` into an `RpcL1Origin`.
    fn from(stored: crate::db::model::StoredL1Origin) -> Self {
        RpcL1Origin {
            block_id: stored.block_id,
            l2_block_hash: stored.l2_block_hash,
            l1_block_height: (stored.l1_block_height != U256::ZERO)
                .then_some(stored.l1_block_height),
            l1_block_hash: (stored.l1_block_hash != B256::ZERO).then_some(stored.l1_block_hash),
            build_payload_args_id: stored.build_payload_args_id,
            is_forced_inclusion: stored.is_forced_inclusion,
            signature: stored.signature,
        }
    }
}

#[cfg(test)]
#[cfg(feature = "db")]
mod test {
    use super::*;

    #[test]
    fn test_rpc_l1_origin_from() {
        let stored_l1_origin = crate::db::model::StoredL1Origin {
            block_id: U256::random(),
            l2_block_hash: B256::random(),
            l1_block_height: U256::random(),
            l1_block_hash: B256::from([1u8; 32]),
            build_payload_args_id: [2u8; 8],
            is_forced_inclusion: true,
            signature: [3u8; 65],
        };

        let rpc_l1_origin: RpcL1Origin = stored_l1_origin.clone().into();
        assert_eq!(stored_l1_origin.block_id, rpc_l1_origin.block_id);
        assert_eq!(stored_l1_origin.l2_block_hash, rpc_l1_origin.l2_block_hash);
        assert_eq!(
            stored_l1_origin.l1_block_height,
            U256::from(rpc_l1_origin.l1_block_height.unwrap())
        );
        assert_eq!(
            stored_l1_origin.l1_block_hash,
            B256::from(rpc_l1_origin.l1_block_hash.unwrap())
        );
        assert_eq!(stored_l1_origin.build_payload_args_id, rpc_l1_origin.build_payload_args_id);
        assert_eq!(stored_l1_origin.is_forced_inclusion, rpc_l1_origin.is_forced_inclusion);
        assert_eq!(stored_l1_origin.signature, rpc_l1_origin.signature);
    }
}
